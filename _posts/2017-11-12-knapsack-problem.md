---
layout:     post
title:      "背包问题"
subtitle:   "Knapsack Problem"
date:       2017-11-12 12:00:00
author:     "HE"
header-img: "img/home-bg.jpg"
header-mask: 0.3
catalog:    true
tags:
    - C++
    - 算法
---

### 01背包问题

##### 问题描述

有$$N$$个物品和一个容量为$$V$$的背包，第$$i$$件物品的费用是$$c[i]$$，对应的价值是$$w[i]$$，**每件物品有且只有一件**，求解将物品放入背包使得价值之和最大

##### 问题求解

01背包问题的基础就是：每件物品有且只有一件（可以选择放入背包，也可以选择不放入背包）

假设$$f[i][v]$$表示前$$i$$件物品和背包容量为$$v$$的最大价值，则01背包问题的状态转移方程是：

$$f[i][v]=max(f[i-1][v], f[i-1][v - c[i]] + w[i])$$

这个方程表示两种情况：

1. 第$$i$$件物品不放进去，则价值之和是$$f[i-1][v]$$

2. 第$$i$$件物品放进去，则价值之和是$$f[i-1][v-c[i]]+w[i]$$

$$v-c[i]$$表示在第$$i$$件物品还没放进去前的背包容量，所以$$f[i-1][v-c[i]]$$就是前$$i-1$$件物品在背包容量为$$v-c[i]$$时的最大价值，也就是说$$f[i-1][v-c[i]]+w[i]$$是第$$i$$件物品放进去后，背包容量为$$v-c[i]+c[i]=v$$时所能得到的最大价值

整个方程式就是比较第$$i$$件物品放进去和不放进去的价值哪个大

可以使用一维数组来空间优化，$$f[v]$$表示容量为$$v$$的背包的最大价值，则当其循环$$N$$次$$(i=0...N-1)$$时（表示从第$$1$$件物品到第$$N$$件物品），最后的$$f[V]$$即为01背包问题的解

伪代码如下：

```c++
for (int i = 0; i < N; i++) {
	for (int j = V; j >= c[i]; j--) {
		f[j] = max(f[j], f[j - c[i]] + w[i]);
	}
}
```

可以发现内循环是倒序的，因为$$max(f[j], f[j - c[i]] + w[i])$$中的值表示的是前一个状态的值，如果采用顺序的形式，在求$$f[j]$$的值时，$$f[j - c[i]]$$的值已经被更新（顺序的原因），这时的$$f[j - c[i]]$$不再表示前一个状态的值，而是表示当前状态的值。

##### hihoCoder 1038

**问题描述：**

且说上一周的故事里，小Hi和小Ho费劲心思终于拿到了茫茫多的奖券！而现在，终于到了小Ho领取奖励的时刻了！

小Ho现在手上有$$M$$张奖券，而奖品区有$$N$$件奖品，分别标号为$$1$$到$$N$$，其中第$$i$$件奖品需要$$need(i)$$张奖券进行兑换，同时也只能兑换一次，为了使得辛苦得到的奖券不白白浪费，小Ho给每件奖品都评了分，其中第$$i$$件奖品的评分值为$$value(i)$$，表示他对这件奖品的喜好值。现在他想知道，凭借他手上的这些奖券，可以换到哪些奖品，使得这些奖品的喜好值之和能够最大。

**输入**

每个测试点（输入文件）有且仅有一组测试数据。

每组测试数据的第一行为两个正整数$$N$$和$$M$$,表示奖品的个数，以及小Ho手中的奖券数。

接下来的$$n$$行描述每一行描述一个奖品，其中第$$i$$行为两个整数$$need(i)$$和$$value(i)$$，意义如前文所述。

测试数据保证

对于$$100%$$的数据，$$N$$的值不超过$$500$$，$$M$$的值不超过$$10^{5}$$

对于$$100%$$的数据，$$need(i)$$不超过$$2 * 10^{5}$$, $$value(i)$$不超过$$10^{3}$$

**输出**

对于每组测试数据，输出一个整数Ans，表示小Ho可以获得的总喜好值。

**Example**

**Input**

```c++
5 1000
144 990
487 436
210 673
567 58
1056 897
```

**Output**

```c++
2099
```

**AC**代码

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
	
	int N, M;
	cin >> N >> M;

	vector<int> need(N, 0);
	vector<int> value(N, 0);
	for (int i = 0; i < N; i++) {
		cin >> need[i] >> value[i];
	}

	vector<int> dp(M + 1, 0);

	for (int i = 0; i < N; i++) {
		for (int j = M; j >= need[i]; j--) {
			dp[j] = max(dp[j], dp[j - need[i]] + value[i]);
		}
	}

	cout << dp[M] << endl;

	return 0;
}
```

### 完全背包问题

##### 问题描述

有$$N$$个物品和一个容量为$$V$$的背包，第$$i$$件物品的费用是$$c[i]$$，对应的价值是$$w[i]$$，**每件物品的数量不限**，求解将物品放入背包使得价值之和最大

##### 问题求解

和01背包不同的是，完全背包问题不限物品的数量

完全背包问题的基础就是：每件物品有无数件（可以选择将$$1$$件放入背包，也可以选择若干件，也可以选择不放入背包）

假设$$f[i][v]$$表示前$$i$$件物品和背包容量为$$v$$的最大价值，则完全背包问题的状态转移方程是：

$$f[i][v] = max(f[i - 1][v - k * c[i]] + k * w[i]),0\leqslant k * c[i] \leqslant v $$

整个方程式就是比较放入不同数量的第$$i$$件物品，使得整个背包价值最大

同样可以用一维数据进行空间优化，这里的$$max(f[i - 1][v - k * c[i]] + k * w[i])$$很明显是和当前的状态比较，看看是否新的状态会比当前状态的价值更大，因此内循环采用顺序即为完全背包问题

```c++
for (int i = 0; i < N; i++) {
	for (int j = c[i]; j <= V; j++) {
		f[j] = max(f[j], f[j - c[i]] + w[i]);
	}
}
```

##### hihoCoder 1043

**问题描述**

且说之前的故事里，小Hi和小Ho费劲心思终于拿到了茫茫多的奖券！而现在，终于到了小Ho领取奖励的时刻了！

等等，这段故事为何似曾相识？这就要从平行宇宙理论说起了………总而言之，在另一个宇宙中，小Ho面临的问题发生了细微的变化！

小Ho现在手上有$$M$$张奖券，而奖品区有$$N$$种奖品，分别标号为$$1$$到$$N$$，其中第$$i$$种奖品需要$$need(i)$$张奖券进行兑换，并且可以兑换**无数次**，为了使得辛苦得到的奖券不白白浪费，小Ho给每件奖品都评了分，其中第$$i$$件奖品的评分值为$$value(i)$$，表示他对这件奖品的喜好值。现在他想知道，凭借他手上的这些奖券，可以换到哪些奖品，使得这些奖品的喜好值之和能够最大。

**输入**

每个测试点（输入文件）有且仅有一组测试数据。

每组测试数据的第一行为两个正整数$$N$$和$$M$$,表示奖品的个数，以及小Ho手中的奖券数。

接下来的$$n$$行描述每一行描述一个奖品，其中第$$i$$行为两个整数$$need(i)$$和$$value(i)$$，意义如前文所述。

测试数据保证

对于$$100%$$的数据，$$N$$的值不超过$$500$$，$$M$$的值不超过$$10^{5}$$

对于$$100%$$的数据，$$need(i)$$不超过$$2 * 10^{5}$$, $$value(i)$$不超过$$10^{3}$$

**输出**

对于每组测试数据，输出一个整数Ans，表示小Ho可以获得的总喜好值。

**Example**

**Input**

```c++
5 1000
144 990
487 436
210 673
567 58
1056 897
```

**Output**

```c++
5940
```

**AC**代码

```c++
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main() {
	int N, M;
	cin >> N >> M;
	vector<int> need(N, 0);
	vector<int> value(N, 0);
	for (int i = 0; i < N; i++) {
		cin >> need[i] >> value[i];
	}

	vector<int> dp(M + 1, 0);

	for (int i = 0; i < N; i++) {
		for (int j = need[i]; j <= M; j++) {
			dp[j] = max(dp[j], dp[j - need[i]] + value[i]);
		}
	}
	cout << dp[M] << endl;

	return 0;
}
```

### 多重背包问题

##### 问题描述

有$$N$$个物品和一个容量为$$V$$的背包，第$$i$$件物品的费用是$$c[i]$$，对应的价值是$$w[i]$$，**每件物品的数量有限**，求解将物品放入背包使得价值之和最大

##### 问题求解

和01背包、完全背包问题都不一样，多重背包问题是每件物品的数量是有限的

多重背包问题的基础就是：每件物品有有限件（至多选择其数量上限放入背包，也可以选择不放入背包）

假设$$f[i][v]$$表示前$$i$$件物品和背包容量为$$v$$的最大价值，则多重背包问题的状态转移方程是，$$n[i]$$表示第$$i$$件物品的件数：

$$f[i][v] = max(f[i - 1][v - k * c[i]] + k * w[i]),0\leqslant k \leqslant n[i] $$

其伪代码如下：

```c++
for (int i = 0; i < N; i++) {
	for (int j = 0; j < n[i]; j++) {
		for (int k = V; k >= c[i]; k--) {
			f[k] = max(f[k], f[k - c[i]] + w[i]);
		}
	}
}
```